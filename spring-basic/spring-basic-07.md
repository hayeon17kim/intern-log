# Section 7. 의존관계 자동 주입

## 다양한 의존관계 주입 방법

- 생성자 주입
- 수정자 주입(setter 주입)
- 필드 주입
- 일반 메서드 주입

### 생성자 주입

- **생성자 호출 시점에 딱 1번만 호출**되는 것이 보장된다.
- 따라서 **불변, 필수** 의존관계에 사용
  - 생성자를 2번 호출할 수는 없다.

> 불변 객체의 `setter`를 `public`으로 만든다면 언젠가 수정이 될 수밖에 없을 것이다. 불변 객체여야 한다면 **수정할 수 있는 모든 가능성을 차단**해야 한다. 언제 어디서 버그가 발생할 지 알 수 없기 때문이다.

**생성자가 1개만 있으면 `@Autowired`를 생략해도 자동 주입된다.** 물론 스프링 빈에만 해당한다.

사실 스프링 컨테이너의 라이프사이클은 두 단계로 나뉘어진다. 스프링 빈을 등록하는 단계, 스프링 빈들의 의존관계를 엮어주는 단계이다. 그러나 **생성자 주입 방식을 사용할 경우 생성자는 빈이 생성될 때 호출**이 되기 때문에 이 단계가 명확히 분리되지는 않는다. 빈을 등록할 때 의존 객체도 엮어준다. 

### 수정자 주입

`setter`라 불리는 필드의 값을 변경하느 수정자 메서드를 통해 의존관계를 주입하는 방법이다.

특징

- **선택, 변경** 가능성이 있는 의존관계에 사용
- 자바빈 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법이다.

```java
@Autowired(required = false)
public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
  this.memberRepository = memberRepository;
  this.discountPolicy = discountPolicy;
}
```

### 필드 주입

- 코드가 간결해서 많은 개발자들을 유혹하지만 **외부에서 변경이 불가능해서 테스트하기 힘들다**는 단점이 있다.
- 임의로 생성하는 객체는 `@Autowired` 가 되지 않아 객체 자체가 생성이 안 된다. 그래도 테스트할 때 임의로 객체를 생성하고 싶다면 의존 객체를 또 따로 생성을 해서 setter로 넣어줘야 하는데, 그러면 setter를 구현해야 한다. 이처럼 필드 주입은 테스트 시 임의로 객체를 생성하기 어렵다. 
- DI 프레임워크가 없으면 아무것도 할 수 없다. 
- 사용하지 말자.
  - 애플리케이션의 실제 코드와 관계 없는 테스트 코드 (`@SpringBootTest`)
  - 스프링 설정을 목적으로 하는 `@Configuration` 같은 곳에서만 특별한 용도로 사용

### 일반 메서드 주입

- 한번에 여러 필드를 주입받을 수 있다.
- 